# ian.heywood@physics.ox.ac.uk


import glob
import numpy
import os
import sys
import time
import shutil
from scipy.stats import zscore


execfile('oxkat/casa_read_project_info.py',globals())
execfile('oxkat/config.py',globals())


def get_table(suffix,ms):
    ll = sorted(glob.glob(GAINTABLES+'/cal_1GC_'+myms+'*'+suffix))
    if len(ll) == 0:
        print('Cannot find one or more of the 1GC gain tables required to proceed with pol cal')
        sys.exit()
    else:
        gaintab = ll[-1] # get the most recent one 
        print('Found: '+gaintab)
    return gaintab


def stamp():
    now = str(datetime.datetime.now()).replace(' ','-').replace(':','-').split('.')[0]
    return now


if not CAL_1GC_DOPOL:
    print('Skipping polarisation calibration as per config settings.')
    sys.exit()
    

myuvrange = CAL_1GC_UVRANGE 
ref_ant = ref_ant[0]

# Find the gaintables generated by the pol-independent 1GC process
# K3, G1, B1, flux3

ktab3 = get_table('K3',myms)
gtab1 = get_table('G1',myms)
bptab1 = get_table('B1',myms)
ftab3 = get_table('flux3',myms)

apply_list = [ktab3,gtab1,bptab1,ftab3]
apply_fields = ['',bpcal,bpcal,'']
apply_interp = ['nearest','linear','linear','linear']


# Setup the filenames for the output gain tables

tt = stamp()
kxtab = GAINTABLES+'/cal_1GC_'+myms+'_'+tt+'.KX'
xftab = GAINTABLES+'/cal_1GC_'+myms+'_'+tt+'.Xf'
dtab = GAINTABLES+'/cal_1GC_'+myms+'_'+tt+'.D'
dftab = GAINTABLES+'/cal_1GC_'+myms+'_'+tt+'.Df'


# Determine which polarisation calibrator is present

if polarcal_tag == 'None':
    print('No polcal identified in project_info file.')
    print('The 1GC setup should have caught this, so something has gone wrong.')
    sys.exit()
elif polarcal_tag == '3C138':
    print('Using 3C138 as primary polarisation calibrator')
    polarcal_model = CAL_1GC_3C138_MODEL
elif polarcal_tag == '3C286':
    print('Using 3C286 as primary polarisation calibrator')
    polarcal_model = CAL_1GC_3C138_MODEL


# Setup visibility model for polarisation calibrator

polflux = polarcal_model[0]
polspix = polarcal_model[1]
polfreq = polarcal_model[2]
polindex = polarcal_model[3]
polangle = polarcal_model[4]

setjy(vis = myms,
    field = polarcal,
    scalebychan = True,
    standard = 'manual',
    fluxdensity = polflux,
    spix = polspix,
    reffreq = polfreq,
    polindex = polindex,
    polangle = polangle,
    usescratch = True)


# Flag based on residual data (since model is in place and polcal corr data is GKB calibrated)

flagdata(vis=myms,
    mode = 'rflag',
    datacolumn = 'residual',
    field = polarcal)

flagdata(vis = myms,
    mode = 'tfcrop',
    datacolumn = 'residual',
    field = polarcal)

if SAVE_FLAGS:
    flagmanager(vis = myms,
        mode = 'save',
        versionname = 'polcal_residual_flags')


# Calibrate cross-hand delays

gaincal(vis = myms,
    caltable = kxtab,
    field = polarcal,
    uvrange = myuvrange,
    solint = 'inf',
    combine = 'obs,scan',
    refant = ref_ant,
    refantmode = 'strict',
    gaintype = 'KCROSS',
    gaintable = apply_list,
    gainfield = apply_fields,
    interp = apply_interp,
    parang = True)

apply_list.append(kxtab)
apply_fields.append(polarcal)
apply_interp.append('nearest')


# Calibrate per-channel cross-hand phases

polcal(vis = myms,
    caltable = xftab,
    field = polarcal,
    uvrange = myuvrange,
    solint = 'inf',
    combine = '',
    refant = ref_ant,
    poltype = 'Xf',
    gaintable = apply_list,
    gainfield = apply_fields,
    interp = apply_interp)

apply_list.append(xftab)
apply_fields.append(polarcal)
apply_interp.append('nearest')


# Calibrate frequency independent bulk leakages

polcal(vis = myms,
    caltable = dtab,
    field = bpcal,
    uvrange = myuvrange,
    solint = 'inf',
    combine = '',
    refant = ref_ant,
    poltype = 'D',
    gaintable = apply_list,
    gainfield = apply_fields,
    interp = apply_interp)

apply_list.append(dtab)
apply_fields.append(bpcal)
apply_interp.append('nearest')


# Calibrate frequency dependent leakages

polcal(vis = myms,
    caltable = dftab,
    field = bpcal,
    uvrange = myuvrange,
    solint = 'inf',
    refant = ref_ant,
    poltype = 'Df',
    gaintable = apply_list,
    gainfield = apply_fields,
    interp = apply_interp)

apply_list.append(dftab)
apply_fields.append(bpcal)
apply_interp.append('nearest')


# Flag Df solutions based on amplitude

dfbackup = dftab+'_preflag'
if os.path.isdir(dfbackup):
    print('Removing existing table '+dfbackup)
    shutil.rmtree(dfbackup)
print('Backing up '+dftab)
shutil.copytree(dftab,dfbackup)

tb.open(dftab,nomodify=False)
gains = tb.getcol('CPARAM')
flags = tb.getcol('FLAG')
masked_gains = numpy.ma.array(gains,mask=flags)
npol = gains.shape[0]
nchans = gains.shape[1]
nant = gains.shape[2]
zgains = zscore(numpy.absolute(masked_gains), axis = 1)
newflags = numpy.logical_or((zgains > 5.0),flags)
tb.putcol('FLAG',newflags)
tb.flush()
tb.done()


# Apply solutions

applycal(vis = myms,
    field = '',
    parang = True,
    gaintable = apply_list,
    gainfield = apply_fields,
    interp = apply_interp)


